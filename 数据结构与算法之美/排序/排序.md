# 排序

## 上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？

最经典、最常用的排序：冒泡排序，插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。
![常见排序算法复杂度](img/常见排序算法复杂度.jpg)

## 思考题：插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？

## 如何分析一个排序算法

**算法的执行效率**
**1、最好情况、最坏情况。平均情况时间复杂度**
处理上述复杂度，还有说出具体什么情况的原始数据会导致这种情况
我们要知道排序算法在不同数据中的性能表现

**2、时间复杂度的系数、常阶、低阶**
对统一阶时间复杂度的排序算法性能对比的时候，我们吧系数、常数、低阶也要考虑进来

**3、比较次数和交换(或交换)次数**
基于比较的排序算法的执行过程，会设计两种操作，一种是元素比较大小，另一种是元素交换或移动，在分析算法的时候应该将比较和移动次数考虑进去

**排序算法的内存消耗**
算法的内存消耗可以使用空间复杂度来衡量。
原地排序，特指空间复杂度是O(1)的排序算法。

**排序算法的稳定性**
稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

## 冒泡排序
冒泡排序只会操作相邻的两个数据。
每次对相邻两个元素进行比较，之后跟前判断进行交换。
一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：
![冒泡过程](img/冒泡过程.jpg)
优化的冒泡排序，增加一个flag，判断是否存在数据交换，如果存在则没有排序完成，反之完成
![是否有交换冒泡](img/是否有交换冒泡.jpg)

具体的冒泡排序：

    /**
     * 冒泡排序，第一层控制冒泡次数，第二层控制相邻元素之间的交换。
     * @param a
     */
    public static void bubbleSort(int[] a){
        if(a.length <= 1){
            return;
        }
        for(int i = 0; i < a.length;i++){ //控制冒泡次数
            boolean flag = false; //增加判断条件，如果已经排序好了及时停止。
            for(int j = 0; j < a.length - i -1; j++){
                if(a[j] > a[j+1]){ //只有a[j] > a[j+1]才会交换位置，等于是不加交换的，保证稳定性
                    int temp = a[j];
                    a[j] = a[j+1];
                    a[j+1] = temp;
                    flag = true;
                }
            }
            if(!flag) break;
        }
    }

三个问题：
**冒泡排序是否是原地排序算法？**
只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。

**冒泡排序是稳定的排序算法吗？**
当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

**冒泡排序的时间复杂度是多少？**
最好情况是O(n),此时数据已经有序，只需做一次冒泡操作；
最坏情况是O(n^2),此时数据刚好事倒序，需要做n次冒泡操作；

平均时间复杂度，通过“有序度”和“逆序度”两个概念来进行分析：
**有序度**是数组中具有有序关系的元素对的个数。

    有序元素对：a[i] <= a[j], 如果i < j。

![有序度](img/有序度.jpg)

对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。

逆序度的定义正好跟有序度相反（默认从小到大为有序）

    逆序元素对：a[i] > a[j], 如果i < j。

**逆序度 = 满有序度 - 有序度**

如果那一开始那个冒泡例子来看
![冒泡过程有序度](img/冒泡过程有序度.jpg)

冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1
交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度。
最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4。

换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。

## 插入排序
将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

![插入排序](img/插入排序.jpg)

一种是元素的比较，一种是元素的移动；
移动操作的次数总是固定的等于逆序度；
![移动元素个数](img/移动元素个数.jpg)

具体代码：
    
    /**
     * 插入排序
     * @param a
     */
    public static void insertionSort(int[] a){
        for(int i = 1; i < a.length; i++){
            int value = a[i]; //记录数据，防止在数据移动过程中被覆盖
            int j = i - 1; //记录空位，即插入位置，在最后可以直接插入
            for(; j >= 0; j--){
                if(a[j] > value){
                    a[j+1] = a[j];
                }else {
                    break;
                }
            }
            a[j+1] = value;
        }
    }

三个问题：
**冒泡排序是否是原地排序算法？**
不需要额外的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。

**冒泡排序是稳定的排序算法吗？**
我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

**冒泡排序的时间复杂度是多少？**
最好情况是O(n),此时数据已经有序
最坏情况是O(n^2),此时数据刚好是倒序，每次插入都相当于在数组的第一个位置插入新的数据；
平均复杂度：数组插入的复杂度是O(n),但是插入排序相等于执行了n次插入操作，平均复杂度是O(n^2)

## 选择排序
但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。
![选择排序原理](img/选择排序原理.jpg)

选择排序空间复杂度为 O(1)，是一种原地排序算法。
选择排序是一种不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

代码：
    
    /**
     * 选择排序
     * @param a
     */
    public static void selectionSort(int [] a){
        for(int i = 0; i < a.length; i++){//遍历数组中所有的位置
            int min = i;//默认该位置上的现有的数就是未排序区最小的
            for(int j = i + 1; j < a.length;j++){//向后遍历
                if(a[j] < a[min]){ //找出更小的数
                    min = j; //记录下标
                }
            }
            int temp = a[i];  //交换位置
            a[i] = a[min];
            a[min] = temp;
        }
    }

## 解答开篇
冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。
插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：

    冒泡排序中数据的交换操作：
    if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;
    }

    插入排序中数据的移动操作：
        if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
        } else {
        break;
    }
我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。

## 冒泡，插入，选择排序小结
![冒泡_插入_选择小结](img/冒泡_插入_选择小结.jpg)