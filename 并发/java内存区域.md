### 基本问题：
1、介绍下Java内存区域（运行时数据区）
2、Java对象的创建过程（默写并知道每一步干什么）
3、对象的访问定位的两种方法（句柄和直接指针两种方法）
### 扩展问题：
1、String类和常量池
2、8种基本类型和包装类和常量池

## 运行时的数据区域
|**线程共享的** | **线程私有的**|
| --------|---------|--------|
|      堆       |  程序计数器    |
|     方法区    |   虚拟机栈     |
|    直接内存   |  本地方法栈    |

### 程序计数器
程序计数器是一块较小的内存空间，是当前执行线程的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取吓一跳需要执行的字节码指令，分支等等功能都需要依赖这个计数器来完成。
为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，这类内存区域线程私有
注：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，他的生命周期随着线程的创建而创建，随之线程的结束而死亡。
### Java虚拟机栈
线程私有、生命周期和线程相同、描述的是Java方法执行的内存模型
Java内存可以粗糙的区分为堆内存和栈内存，**栈是虚拟机栈或者说是虚拟机栈中的局部变量表部分。**
局部变量表主要存放了编译器可知的各种数据类型（boolean，byte，char，short，int，float，long，double），对象引用（reference类型）
Java虚拟机栈两种异常：StackOverFlowError和OutOfMemoryError
StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当前请求栈深度超过当前Java虚拟栈最大深度的时候，就会抛出StackOverFlowError异常
OutOfMemoryError：若Java虚拟机的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法在动态扩展了，此时抛出OutOfMemoryError异常。
### 本地方法栈
虚拟机栈为虚拟机执行Java方法也就是字节码服务，而本地方法栈则为虚拟机使用的Native方法服务。在HotSpot虚拟机中和Java虚拟机栈合二为一。
### 堆
JAVA虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一目的是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆。

### 方法区
方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机把方法区描述为堆的一个逻辑部分，但是他却又一个别名Non-Heap，目的是和Java堆区分开。

### 运行时常量池
JDK1.7及之后版本的JVM已经将运行时的常量池从方法区中移了出来，在Java堆中开辟出一块区域存放运行时常量池。

### 直接内存
直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。


》》》待续
